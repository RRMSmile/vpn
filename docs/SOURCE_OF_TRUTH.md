# Source of truth: DB-first control plane

Цель: жёстко зафиксировать, как CloudGate поддерживает консистентность между БД и WireGuard-нодой.

## TL;DR

База данных является источником истины.
WireGuard node является исполняющим слоем.

Это означает:
- мы НЕ читаем состояние ноды как первичное
- мы НЕ "догадываемся" по `wg show`, что должно быть в БД
- мы приводим ноду к состоянию БД (reconciliation)

## Почему это важно

WireGuard не хранит бизнес-логику:
- подписки
- лимиты
- жизненный цикл устройства
- историю действий

Поэтому бизнес-решение живёт в БД, а нода только применяет команды.

## Инварианты

1) Peer ACTIVE в БД -> peer должен быть на ноде.
2) Peer REVOKED/DELETED в БД -> peer не должен быть на ноде.
3) Любой "дрейф" на ноде исправляется reconciliation-процедурой.

## Идемпотентность

Любой provisioning/revoke должен быть безопасен при повторении:
- Повторный provision на тот же Device не создаёт второй peer.
- Повторный revoke не должен падать как ошибка сценария.

## Транзакционная логика (практично)

Идеальная схема:
1) Создать/обновить запись в БД в транзакции
2) Применить на ноде
3) Зафиксировать статус применения

Если на шаге 2 ошибка:
- записать ошибку применения
- оставить объект в состоянии, которое reconciliation сможет поправить

## Reconciliation (must-have для сервиса)

Периодическая задача:
- собирает desired state из БД
- собирает actual state из `wg show wg0 dump`
- вычисляет diff
- применяет команды, чтобы actual == desired

Пример diff:
- в БД peer ACTIVE, на ноде нет -> add
- в БД peer REVOKED, на ноде есть -> remove
- на ноде есть лишний peer -> remove (если не найден в БД)

Результат:
- сервис переживает перезапуски
- сервис переживает временные SSH ошибки
- ручные правки на ноде не ломают продукт надолго

## Следующий шаг

Добавить reconcile-скрипт и запускать:
- по cron (каждые 1-5 минут)
- и/или при старте API
